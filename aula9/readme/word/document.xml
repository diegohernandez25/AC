<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<w:document xmlns:wpc="http://schemas.microsoft.com/office/word/2010/wordprocessingCanvas" xmlns:cx="http://schemas.microsoft.com/office/drawing/2014/chartex" xmlns:cx1="http://schemas.microsoft.com/office/drawing/2015/9/8/chartex" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" xmlns:o="urn:schemas-microsoft-com:office:office" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math" xmlns:v="urn:schemas-microsoft-com:vml" xmlns:wp14="http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing" xmlns:wp="http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing" xmlns:w10="urn:schemas-microsoft-com:office:word" xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main" xmlns:w14="http://schemas.microsoft.com/office/word/2010/wordml" xmlns:w15="http://schemas.microsoft.com/office/word/2012/wordml" xmlns:w16se="http://schemas.microsoft.com/office/word/2015/wordml/symex" xmlns:wpg="http://schemas.microsoft.com/office/word/2010/wordprocessingGroup" xmlns:wpi="http://schemas.microsoft.com/office/word/2010/wordprocessingInk" xmlns:wne="http://schemas.microsoft.com/office/word/2006/wordml" xmlns:wps="http://schemas.microsoft.com/office/word/2010/wordprocessingShape" mc:Ignorable="w14 w15 w16se wp14"><w:body><w:p w:rsidR="00D14495" w:rsidRDefault="00ED71DE" w:rsidP="00ED71DE"><w:pPr><w:jc w:val="both"/></w:pPr><w:r><w:t>Na linguagem Java todo o tipo de dados é encapsulado e representado por um objeto, mesmo que tenha apenas um atributo. Isto implica que um algoritmo recursivo que processa um atributo de tipo lista ou árvore tem de ser decomposto em duas funções. A função de arranque que valida algumas condições, invoca a função recursiva e depois devolve o resultado da função.</w:t></w:r><w:r w:rsidR="00C0503C"><w:t xml:space="preserve"> E a função que faz a travessia recursiva e que implementa o algoritmo pretendido.</w:t></w:r><w:r><w:t xml:space="preserve"> A linguagem Java não tem passagem por referência pelo que os algoritmos de inserção/remoção utilizam o retorno da função para atualizar as ligações entre os elementos, limitando-lhes a sua operacionalidade.</w:t></w:r></w:p><w:p w:rsidR="00ED71DE" w:rsidRDefault="00ED71DE" w:rsidP="00483DA5"><w:pPr><w:spacing w:after="0"/><w:jc w:val="both"/></w:pPr></w:p><w:p w:rsidR="00ED71DE" w:rsidRDefault="00ED71DE" w:rsidP="00ED71DE"><w:pPr><w:jc w:val="both"/></w:pPr><w:r><w:t>Na linguagem C quando temos um tipo de dados com apenas um campo de tipo ponteiro que serve de ponto de acesso à estrutura de dados não precisamos de encapsular o tipo de dados numa estrutura. Usamos apenas um ponteiro diretamente para a estrutura de dados. Tal poderia ter sido feito na implementação dinâmica do tipo sequência se, por exemplo, tivéssemos apenas um ponteiro para a cabeça da lista e não utilizássemos o indicador de números de elementos.</w:t></w:r></w:p><w:p w:rsidR="00483DA5" w:rsidRDefault="00483DA5" w:rsidP="00483DA5"><w:pPr><w:spacing w:after="0"/><w:jc w:val="both"/></w:pPr></w:p><w:p w:rsidR="00ED71DE" w:rsidRDefault="00ED71DE" w:rsidP="00ED71DE"><w:pPr><w:jc w:val="both"/></w:pPr><w:r><w:t xml:space="preserve">Esta implementação mais simples que vai ser usada no caso da árvore binária de pesquisa tem vantagens e desvantagens. A principal desvantagem é que não podemos distinguir a inexistência de uma árvore (NO_ABP) de ela existir e estar vazia (ABP_EMPTY), porque em ambos os casos temos um ponteiro nulo. Uma vez que estamos numa implementação simplificada vamos considerar que o ponteiro nulo é indicativo de árvore vazia e o código de erro </w:t></w:r><w:r w:rsidR="00C0503C"><w:t>(</w:t></w:r><w:r w:rsidR="00C0503C"><w:t xml:space="preserve">árvore vazia </w:t></w:r><w:r w:rsidR="00C0503C"><w:t xml:space="preserve">NO_ABP) </w:t></w:r><w:r><w:t xml:space="preserve">está declarado na interface apenas por uma questão de coerência e de </w:t></w:r><w:r w:rsidR="004C60E5"><w:t xml:space="preserve">consistência </w:t></w:r><w:r><w:t>com os restantes tipos de dados usados nas aulas práticas.</w:t></w:r></w:p><w:p w:rsidR="00483DA5" w:rsidRDefault="00483DA5" w:rsidP="00483DA5"><w:pPr><w:spacing w:after="0"/><w:jc w:val="both"/></w:pPr></w:p><w:p w:rsidR="00ED71DE" w:rsidRDefault="004C60E5" w:rsidP="00ED71DE"><w:pPr><w:jc w:val="both"/></w:pPr><w:r><w:t xml:space="preserve">A grande vantagem desta implementação é que os algoritmos recursivos podem ser invocados diretamente a partir da raiz da árvore (ver por exemplo as funções </w:t></w:r><w:proofErr w:type="spellStart"/><w:r w:rsidRPr="004C60E5"><w:t>ABPSize</w:t></w:r><w:proofErr w:type="spellEnd"/><w:r><w:t xml:space="preserve"> e </w:t></w:r><w:proofErr w:type="spellStart"/><w:r w:rsidRPr="004C60E5"><w:t>ABPMinRec</w:t></w:r><w:proofErr w:type="spellEnd"/><w:r><w:t xml:space="preserve">). Se bem que por vezes para simplificar o algoritmo recursivo </w:t></w:r><w:r w:rsidR="00144416"><w:t>em termos de validações desnecessárias repetidamente e</w:t></w:r><w:r><w:t xml:space="preserve"> permitir um melhor controlo de erro seja aconselhável partir o algoritmo em duas partes (ver por exemplo a função </w:t></w:r><w:proofErr w:type="spellStart"/><w:r w:rsidRPr="004C60E5"><w:t>ABPKMin</w:t></w:r><w:proofErr w:type="spellEnd"/><w:r><w:t>).</w:t></w:r></w:p><w:p w:rsidR="00483DA5" w:rsidRDefault="00483DA5" w:rsidP="00483DA5"><w:pPr><w:spacing w:after="0"/><w:jc w:val="both"/></w:pPr></w:p><w:p w:rsidR="004C60E5" w:rsidRDefault="004C60E5" w:rsidP="004C60E5"><w:pPr><w:jc w:val="both"/></w:pPr><w:r><w:t>Nos algoritmos de árvores é fundamental assegurar que só se processa árvores não vazias pelo que a verificação de ponteiro nulo (</w:t></w:r><w:proofErr w:type="spellStart"/><w:r><w:t>if</w:t></w:r><w:proofErr w:type="spellEnd"/><w:r><w:t xml:space="preserve"> (</w:t></w:r><w:proofErr w:type="spellStart"/><w:r><w:t>proot</w:t></w:r><w:proofErr w:type="spellEnd"/><w:r><w:t xml:space="preserve"> == NULL) terminar) antes de implementar qualquer algoritmo é essencial para que os algoritmos – em particular os recursivos –não estoirem.</w:t></w:r></w:p><w:p w:rsidR="00483DA5" w:rsidRDefault="00483DA5" w:rsidP="00483DA5"><w:pPr><w:spacing w:after="0"/><w:jc w:val="both"/></w:pPr></w:p><w:p w:rsidR="00487708" w:rsidRDefault="00404A30" w:rsidP="00404A30"><w:pPr><w:jc w:val="both"/></w:pPr><w:r><w:t xml:space="preserve">A linguagem C permite a passagem por referência e tem operadores que permitem obter o endereço de uma variável (operador &amp;) e para obter o valor referenciado (operador *). Por isso na implementação de </w:t></w:r><w:r w:rsidR="004C60E5"><w:t>algoritmos de árvores</w:t></w:r><w:r><w:t xml:space="preserve"> a atualização das ligações entre os nós é </w:t></w:r><w:r w:rsidR="00487708"><w:t>geralmente</w:t></w:r><w:r><w:t xml:space="preserve"> feita através da passagem de parâmetros. Assim nos algoritmos de inserção/remoção o ponteiro para a raiz é passado como ponteiro para ponteiro para a raiz da árvore (</w:t></w:r><w:proofErr w:type="spellStart"/><w:r w:rsidRPr="00404A30"><w:t>PtABPNode</w:t></w:r><w:proofErr w:type="spellEnd"/><w:r w:rsidRPr="00404A30"><w:t xml:space="preserve"> </w:t></w:r><w:r><w:t>*</w:t></w:r><w:proofErr w:type="spellStart"/><w:r w:rsidRPr="00404A30"><w:t>proot</w:t></w:r><w:proofErr w:type="spellEnd"/><w:r><w:t>).</w:t></w:r><w:r w:rsidR="00C0503C"><w:t xml:space="preserve"> Isto porque a inserção altera a raiz da árvore</w:t></w:r><w:r w:rsidR="00487708"><w:t>, quando, por exemplo, a árvore</w:t></w:r><w:r w:rsidR="00C0503C"><w:t xml:space="preserve"> está vazia</w:t></w:r><w:r w:rsidR="00487708"><w:t>. E,</w:t></w:r><w:r w:rsidR="00C0503C"><w:t xml:space="preserve"> a </w:t></w:r><w:r w:rsidR="00C0503C"><w:t xml:space="preserve">remoção </w:t></w:r><w:r w:rsidR="00487708"><w:t>pode alterar a raiz da árvore</w:t></w:r><w:r w:rsidR="00487708"><w:t xml:space="preserve">, </w:t></w:r><w:r w:rsidR="00487708"><w:t>quando, por exemplo</w:t></w:r><w:r w:rsidR="00487708"><w:t>,</w:t></w:r><w:r w:rsidR="00487708"><w:t xml:space="preserve"> </w:t></w:r><w:r w:rsidR="00487708"><w:t>o nó da raiz é eliminado.</w:t></w:r></w:p><w:p w:rsidR="00C0503C" w:rsidRDefault="00C0503C" w:rsidP="00404A30"><w:pPr><w:jc w:val="both"/></w:pPr><w:r><w:t xml:space="preserve">Para aceder a um campo do nó, por exemplo, ao elemento armazenado no nó temos que fazer </w:t></w:r><w:r w:rsidRPr="00C0503C"><w:rPr><w:b/></w:rPr><w:t>(*</w:t></w:r><w:proofErr w:type="spellStart"/><w:proofErr w:type="gramStart"/><w:r w:rsidRPr="00C0503C"><w:rPr><w:b/></w:rPr><w:t>proot</w:t></w:r><w:proofErr w:type="spellEnd"/><w:r w:rsidRPr="00C0503C"><w:rPr><w:b/></w:rPr><w:t>)-</w:t></w:r><w:proofErr w:type="gramEnd"/><w:r w:rsidRPr="00C0503C"><w:rPr><w:b/></w:rPr><w:t>&gt;</w:t></w:r><w:r><w:rPr><w:b/></w:rPr><w:t>Elem</w:t></w:r><w:r><w:t xml:space="preserve"> e para obter um ponteiro, por exemplo, </w:t></w:r><w:r w:rsidR="002D090C"><w:t>para a subárvore</w:t></w:r><w:r w:rsidR="002D090C"><w:t xml:space="preserve"> </w:t></w:r><w:r><w:t xml:space="preserve">esquerda </w:t></w:r><w:r w:rsidR="002D090C"><w:t xml:space="preserve">temos </w:t></w:r><w:r><w:t xml:space="preserve">que fazer </w:t></w:r><w:r w:rsidRPr="00C0503C"><w:rPr><w:b/></w:rPr><w:t>&amp;</w:t></w:r><w:r w:rsidRPr="00C0503C"><w:rPr><w:b/></w:rPr><w:t>(*</w:t></w:r><w:proofErr w:type="spellStart"/><w:r w:rsidRPr="00C0503C"><w:rPr><w:b/></w:rPr><w:t>proot</w:t></w:r><w:proofErr w:type="spellEnd"/><w:r w:rsidRPr="00C0503C"><w:rPr><w:b/></w:rPr><w:t>)-&gt;</w:t></w:r><w:proofErr w:type="spellStart"/><w:r><w:rPr><w:b/></w:rPr><w:t>PtLeft</w:t></w:r><w:proofErr w:type="spellEnd"/><w:r><w:t>.</w:t></w:r><w:r><w:t xml:space="preserve"> Repare que o operador primário -&gt; tem precedência sobre os operadores unários * e &amp; pelo que é preciso parênteses curvos para fazer a </w:t></w:r><w:r><w:t xml:space="preserve">avaliação </w:t></w:r><w:r><w:t xml:space="preserve">prévia do ponteiro </w:t></w:r><w:proofErr w:type="spellStart"/><w:r><w:t>proot</w:t></w:r><w:proofErr w:type="spellEnd"/><w:r><w:t xml:space="preserve"> passado por referência antes de aceder ao campo pretendido seja para obter o seu valor ou um ponteiro</w:t></w:r><w:r w:rsidR="002D090C"><w:t xml:space="preserve"> para ele</w:t></w:r><w:r><w:t>.</w:t></w:r></w:p><w:p w:rsidR="004C60E5" w:rsidRDefault="004C60E5" w:rsidP="004C60E5"><w:pPr><w:jc w:val="both"/></w:pPr><w:r><w:lastRenderedPageBreak/><w:t xml:space="preserve">Nos algoritmos </w:t></w:r><w:r w:rsidR="00404A30"><w:t xml:space="preserve">recursivos </w:t></w:r><w:r><w:t>de árvores o resultado é devolvido</w:t></w:r><w:r w:rsidR="00404A30"><w:t xml:space="preserve"> através do retorno da função (ver por exemplo a função </w:t></w:r><w:proofErr w:type="spellStart"/><w:r w:rsidR="00404A30" w:rsidRPr="004C60E5"><w:t>ABPSize</w:t></w:r><w:proofErr w:type="spellEnd"/><w:r w:rsidR="00404A30"><w:t xml:space="preserve">), utilizando eventualmente variáveis locais para facilitar o cálculo do resultado função (ver por exemplo a função </w:t></w:r><w:proofErr w:type="spellStart"/><w:r w:rsidR="00404A30" w:rsidRPr="00404A30"><w:t>ABPHeight</w:t></w:r><w:proofErr w:type="spellEnd"/><w:r w:rsidR="00404A30"><w:t xml:space="preserve">). Em caso algum devem ser usadas variáveis globais </w:t></w:r><w:proofErr w:type="spellStart"/><w:r w:rsidR="00404A30"><w:t>static</w:t></w:r><w:proofErr w:type="spellEnd"/><w:r w:rsidR="00404A30"><w:t xml:space="preserve"> porque elas não podem ser reinicializadas num algoritmo recursivo.</w:t></w:r><w:r w:rsidR="00483DA5"><w:t xml:space="preserve"> </w:t></w:r><w:r w:rsidR="00144416"><w:t>Por outro lado,</w:t></w:r><w:r w:rsidR="00483DA5"><w:t xml:space="preserve"> a utilização de </w:t></w:r><w:r w:rsidR="00404A30"><w:t>variáve</w:t></w:r><w:r w:rsidR="00483DA5"><w:t>is</w:t></w:r><w:r w:rsidR="00404A30"><w:t xml:space="preserve"> </w:t></w:r><w:r w:rsidR="00483DA5"><w:t>locais permite um melhor controlo sobre a atualização da variável de erro.</w:t></w:r></w:p><w:p w:rsidR="00144416" w:rsidRDefault="002D090C" w:rsidP="00144416"><w:pPr><w:spacing w:after="0"/><w:jc w:val="both"/></w:pPr><w:r><w:t xml:space="preserve">Em </w:t></w:r><w:r w:rsidR="00144416"><w:t>a</w:t></w:r><w:r><w:t>lgumas</w:t></w:r><w:r w:rsidR="0059334E"><w:t xml:space="preserve"> implementações recursivas </w:t></w:r><w:r><w:t xml:space="preserve">(por exemplo de </w:t></w:r><w:r w:rsidR="00144416"><w:t xml:space="preserve">funções </w:t></w:r><w:r><w:t xml:space="preserve">do género da </w:t></w:r><w:proofErr w:type="spellStart"/><w:r w:rsidR="00144416"><w:t>ABP</w:t></w:r><w:r w:rsidR="0059334E"><w:t>FloorValue</w:t></w:r><w:proofErr w:type="spellEnd"/><w:r w:rsidR="0059334E"><w:t xml:space="preserve"> e </w:t></w:r><w:r><w:t xml:space="preserve">da </w:t></w:r><w:proofErr w:type="spellStart"/><w:r w:rsidR="0059334E"><w:t>ABPCeilValue</w:t></w:r><w:proofErr w:type="spellEnd"/><w:r><w:t>)</w:t></w:r><w:r w:rsidR="0059334E"><w:t xml:space="preserve"> não é possível distinguir a situação de árvore vazia d</w:t></w:r><w:r><w:t>a</w:t></w:r><w:r w:rsidR="0059334E"><w:t xml:space="preserve"> inexistência do elemento procurado, porque neste caso o algoritmo atinge sempre um nó exterior (subárvore vazia)</w:t></w:r><w:r><w:t xml:space="preserve"> e devolve o erro ABP_EMPTY</w:t></w:r><w:r w:rsidR="0059334E"><w:t>. A solução passa por uma implementação repetitiva ou por decompor o algoritmo recursivo em duas funções.</w:t></w:r><w:r w:rsidR="002D4E53"><w:t xml:space="preserve"> Em alternativa, pode ser utilizado apenas o código de erro NO_ELEM e ao nível do programa não invocar estas funções para árvores vazias (programação por contrato com pré-condição de a árvore não estar vazia).</w:t></w:r></w:p><w:p w:rsidR="0059334E" w:rsidRDefault="0059334E" w:rsidP="00144416"><w:pPr><w:spacing w:after="0"/><w:jc w:val="both"/></w:pPr></w:p><w:p w:rsidR="00144416" w:rsidRDefault="0059334E" w:rsidP="0059334E"><w:pPr><w:spacing w:after="0"/><w:jc w:val="both"/></w:pPr><w:r><w:t>Nos algoritmos repetitivos de árvores que exigem a utilização de uma memória auxiliar de tipo fila ou pilha as operações de criação (</w:t></w:r><w:proofErr w:type="spellStart"/><w:r><w:t>QueueCreate</w:t></w:r><w:proofErr w:type="spellEnd"/><w:r><w:t>/</w:t></w:r><w:proofErr w:type="spellStart"/><w:r><w:t>StackCreate</w:t></w:r><w:proofErr w:type="spellEnd"/><w:r><w:t>) e de inserção de elementos (</w:t></w:r><w:proofErr w:type="spellStart"/><w:r><w:t>QueueEnqueue</w:t></w:r><w:proofErr w:type="spellEnd"/><w:r><w:t>/</w:t></w:r><w:proofErr w:type="spellStart"/><w:r><w:t>StackPush</w:t></w:r><w:proofErr w:type="spellEnd"/><w:r><w:t>) têm que ser testadas para assegurar que a alocação de memória</w:t></w:r><w:r w:rsidR="00273D0A"><w:t>.</w:t></w:r><w:r><w:t xml:space="preserve"> </w:t></w:r><w:r w:rsidR="002D090C"><w:t>Quando a função termina, seja e</w:t></w:r><w:r><w:t xml:space="preserve">m caso de erro ou quando </w:t></w:r><w:r w:rsidR="002D090C"><w:t>acaba o processamento da árvore</w:t></w:r><w:r w:rsidR="002D4E53"><w:t xml:space="preserve">, a fila/pilha deve ser destruída </w:t></w:r><w:r><w:t>(</w:t></w:r><w:proofErr w:type="spellStart"/><w:r><w:t>QueueDestroy</w:t></w:r><w:proofErr w:type="spellEnd"/><w:r><w:t>/</w:t></w:r><w:proofErr w:type="spellStart"/><w:r><w:t>StackDestroy</w:t></w:r><w:proofErr w:type="spellEnd"/><w:r><w:t xml:space="preserve">). </w:t></w:r><w:r w:rsidR="00273D0A"><w:t xml:space="preserve">No caso das funções apresentadas no módulo (como por exemplo as funções </w:t></w:r><w:proofErr w:type="spellStart"/><w:r w:rsidR="00273D0A" w:rsidRPr="00273D0A"><w:t>ABPByLevel</w:t></w:r><w:proofErr w:type="spellEnd"/><w:r w:rsidR="00273D0A"><w:t xml:space="preserve"> e </w:t></w:r><w:proofErr w:type="spellStart"/><w:r w:rsidR="00273D0A" w:rsidRPr="00273D0A"><w:t>ABPSizeRep</w:t></w:r><w:proofErr w:type="spellEnd"/><w:r w:rsidR="00273D0A"><w:t>) elas estão implementadas de forma simplificada não fazendo totalmente a controlo d</w:t></w:r><w:r w:rsidR="002D4E53"><w:t>est</w:t></w:r><w:r w:rsidR="00273D0A"><w:t>as operações, nomeada</w:t></w:r><w:r w:rsidR="002D090C"><w:t xml:space="preserve">mente na inserção de elementos. </w:t></w:r><w:bookmarkStart w:id="0" w:name="_GoBack"/><w:bookmarkEnd w:id="0"/><w:r w:rsidR="002D090C"><w:t xml:space="preserve">Mas tenha em atenção </w:t></w:r><w:r><w:t xml:space="preserve">que na função </w:t></w:r><w:proofErr w:type="spellStart"/><w:r><w:t>ABPElements</w:t></w:r><w:proofErr w:type="spellEnd"/><w:r><w:t xml:space="preserve"> a fila onde se colocam os elementos inteiros </w:t></w:r><w:r w:rsidR="00273D0A"><w:t>é criada e depois é destruída pela aplicação, pelo que só é necessário validar a inserção dos elementos na fila.</w:t></w:r></w:p><w:p w:rsidR="00144416" w:rsidRDefault="00144416" w:rsidP="00144416"><w:pPr><w:jc w:val="both"/></w:pPr></w:p><w:sectPr w:rsidR="00144416" w:rsidSect="00144416"><w:pgSz w:w="11906" w:h="16838"/><w:pgMar w:top="1134" w:right="1701" w:bottom="1134" w:left="1701" w:header="709" w:footer="709" w:gutter="0"/><w:cols w:space="708"/><w:docGrid w:linePitch="360"/></w:sectPr></w:body></w:document>